<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains all the methods used for onchain interaction, especially with Safe instance, Mutlicall, and Multisend contracts."><title>hopli_lib::methods - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-80aa586b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="hopli_lib" data-themes="" data-resource-suffix="" data-rustdoc-version="1.94.0-nightly (e7d44143a 2025-12-24)" data-channel="nightly" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-3e30299d.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module methods</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../hopli_lib/index.html">hopli_<wbr>lib</a><span class="version">0.13.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module methods</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate hopli_<wbr>lib</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">hopli_lib</a></div><h1>Module <span>methods</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/hopli_lib/methods.rs.html#1-2085">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contains all the methods used for onchain interaction, especially with Safe instance, Mutlicall, and
Multisend contracts.</p>
<p><a href="enum.SafeTxOperation.html" title="enum hopli_lib::methods::SafeTxOperation">SafeTxOperation</a> corresponds to the <code>Operation</code> Enum used in Safe smart contract.</p>
<p><a href="struct.MultisendTransaction.html" title="struct hopli_lib::methods::MultisendTransaction">MultisendTransaction</a> struct is used for building transactions interacting with Multisend contract</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="IMulticall3Extract/index.html" title="mod hopli_lib::methods::IMulticall3Extract">IMulticall3<wbr>Extract</a></dt><dd>Module containing a contract’s types and functions.</dd><dt><a class="mod" href="ModuleSingleton/index.html" title="mod hopli_lib::methods::ModuleSingleton">Module<wbr>Singleton</a></dt><dd>Module containing a contract’s types and functions.</dd><dt><a class="mod" href="SafeSingleton/index.html" title="mod hopli_lib::methods::SafeSingleton">Safe<wbr>Singleton</a></dt><dd>Module containing a contract’s types and functions.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.MultisendTransaction.html" title="struct hopli_lib::methods::MultisendTransaction">Multisend<wbr>Transaction</a></dt><dd>Struct to make a multisend transaction, mainly used by safe instances</dd><dt><a class="struct" href="struct.multiSendCall.html" title="struct hopli_lib::methods::multiSendCall">multi<wbr>Send<wbr>Call</a></dt><dd>Function with signature <code>multiSend(bytes)</code> and selector <code>0x8d80ff0a</code>.</dd><dt><a class="struct" href="struct.multiSendReturn.html" title="struct hopli_lib::methods::multiSendReturn">multi<wbr>Send<wbr>Return</a></dt><dd>Container type for the return parameters of the <a href="struct.multiSendCall.html" title="struct hopli_lib::methods::multiSendCall"><code>multiSend(bytes)</code></a> function.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.SafeTxOperation.html" title="enum hopli_lib::methods::SafeTxOperation">Safe<wbr>TxOperation</a></dt><dd>Enums of Safe transaction operation</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.create_rpc_client_to_anvil.html" title="fn hopli_lib::methods::create_rpc_client_to_anvil">create_<wbr>rpc_<wbr>client_<wbr>to_<wbr>anvil</a></dt><dd>Used for testing. Creates RPC client to the local Anvil instance.</dd><dt><a class="fn" href="fn.debug_node_safe_module_setup_main.html" title="fn hopli_lib::methods::debug_node_safe_module_setup_main">debug_<wbr>node_<wbr>safe_<wbr>module_<wbr>setup_<wbr>main</a></dt><dd>Quick check if the following values are correct, for one single node:
4. If Safe is owned by the correct owner(s)
5. Safe’s wxHOPR balance and allowance
6. if the module is enabled
7. if node is included in the module
8. Get all the targets of the safe (then check if channel and announcement are there)
9. Get the owner of the module</dd><dt><a class="fn" href="fn.debug_node_safe_module_setup_on_balance_and_registries.html" title="fn hopli_lib::methods::debug_node_safe_module_setup_on_balance_and_registries">debug_<wbr>node_<wbr>safe_<wbr>module_<wbr>setup_<wbr>on_<wbr>balance_<wbr>and_<wbr>registries</a></dt><dd>Quick check if the following values are correct, for one single node:</dd><dt><a class="fn" href="fn.deploy_safe_module_for_single_edge_node.html" title="fn hopli_lib::methods::deploy_safe_module_for_single_edge_node">deploy_<wbr>safe_<wbr>module_<wbr>for_<wbr>single_<wbr>edge_<wbr>node</a></dt><dd>Deploy a safe and a module, while sending tokens to the safe for single edge node.
It’s possible to only deploy a safe and a module without onboarding the node
Alternatively, the node will be included in the module after deployment
Returns safe proxy address and module proxy address</dd><dt><a class="fn" href="fn.deploy_safe_module_with_targets_and_nodes.html" title="fn hopli_lib::methods::deploy_safe_module_with_targets_and_nodes">deploy_<wbr>safe_<wbr>module_<wbr>with_<wbr>targets_<wbr>and_<wbr>nodes</a></dt><dd>Deploy a safe and a module proxies via v4 HoprStakeFactory contract with default permissions and announcement
targets With the multicall contract, it deploys a safe proxy instance and a module proxy instance with multicall as
an owner, and completes necessary setup.
Then the multicall includes some additional steps:</dd><dt><a class="fn" href="fn.deregister_nodes_from_node_safe_registry_and_remove_from_module.html" title="fn hopli_lib::methods::deregister_nodes_from_node_safe_registry_and_remove_from_module">deregister_<wbr>nodes_<wbr>from_<wbr>node_<wbr>safe_<wbr>registry_<wbr>and_<wbr>remove_<wbr>from_<wbr>module</a></dt><dd>Deregister safes and nodes from the node-safe registry.
It returns the number of removed nodes</dd><dt><a class="fn" href="fn.get_chain_id_and_safe_nonce.html" title="fn hopli_lib::methods::get_chain_id_and_safe_nonce">get_<wbr>chain_<wbr>id_<wbr>and_<wbr>safe_<wbr>nonce</a></dt><dd>Get chain id and safe nonce</dd><dt><a class="fn" href="fn.get_native_and_token_balances.html" title="fn hopli_lib::methods::get_native_and_token_balances">get_<wbr>native_<wbr>and_<wbr>token_<wbr>balances</a></dt><dd>Get native balance and hopr token balance for given addresses</dd><dt><a class="fn" href="fn.get_registered_safes_for_nodes_on_node_safe_registry.html" title="fn hopli_lib::methods::get_registered_safes_for_nodes_on_node_safe_registry">get_<wbr>registered_<wbr>safes_<wbr>for_<wbr>nodes_<wbr>on_<wbr>node_<wbr>safe_<wbr>registry</a></dt><dd>Get registered safes for given nodes on the node-safe registry</dd><dt><a class="fn" href="fn.include_nodes_to_module.html" title="fn hopli_lib::methods::include_nodes_to_module">include_<wbr>nodes_<wbr>to_<wbr>module</a></dt><dd>Include nodes to the module</dd><dt><a class="fn" href="fn.migrate_nodes.html" title="fn hopli_lib::methods::migrate_nodes">migrate_<wbr>nodes</a></dt><dd>Migrate nodes to be able to run in a new network.</dd><dt><a class="fn" href="fn.predict_module_address.html" title="fn hopli_lib::methods::predict_module_address">predict_<wbr>module_<wbr>address</a></dt><dd>Helper function to predict module address. Note that here the caller is the contract deployer
FIXME: The result mismatch from predicted module address from smart contract</dd><dt><a class="fn" href="fn.predict_safe_address.html" title="fn hopli_lib::methods::predict_safe_address">predict_<wbr>safe_<wbr>address</a></dt><dd>Helper function to predict safe address</dd><dt><a class="fn" href="fn.prepare_safe_tx_multicall_payload_from_owner_contract.html" title="fn hopli_lib::methods::prepare_safe_tx_multicall_payload_from_owner_contract">prepare_<wbr>safe_<wbr>tx_<wbr>multicall_<wbr>payload_<wbr>from_<wbr>owner_<wbr>contract</a></dt><dt><a class="fn" href="fn.send_multisend_safe_transaction_with_threshold_one.html" title="fn hopli_lib::methods::send_multisend_safe_transaction_with_threshold_one">send_<wbr>multisend_<wbr>safe_<wbr>transaction_<wbr>with_<wbr>threshold_<wbr>one</a></dt><dd>Use safe to delegatecall to multisend contract
Note that when no additional signature is provided, the safe must have a threshold of one,
so that the transaction can be executed.
Note that the refund address is the caller (safe owner) wallet</dd><dt><a class="fn" href="fn.transfer_native_tokens.html" title="fn hopli_lib::methods::transfer_native_tokens">transfer_<wbr>native_<wbr>tokens</a></dt><dd>Transfer some native tokens from the caller to the list of addresses
Address_i receives amounts_i native tokens.</dd><dt><a class="fn" href="fn.transfer_or_mint_tokens.html" title="fn hopli_lib::methods::transfer_or_mint_tokens">transfer_<wbr>or_<wbr>mint_<wbr>tokens</a></dt><dd>Transfer some HOPR tokens from the caller to the list of addresses
Address_i receives amounts_i HOPR tokens.
When there’s not enough token in caller’s balance, if the caller is
a minter, mint the missing tokens. If not, returns error</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.AnvilRpcClient.html" title="type hopli_lib::methods::AnvilRpcClient">Anvil<wbr>RpcClient</a></dt></dl></section></div></main></body></html>